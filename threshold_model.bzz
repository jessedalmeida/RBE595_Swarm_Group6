
#
# Executed once at init time
#
function init() {
  reset()
}

#
# Executed for each step
#
function step() {

  obst = reduce(proximity,
		function(idx,sensor,sofar) {
			return {
				.x = sofar.x + sensor.value * math.cos(sensor.angle),
				.y = sofar.y + sensor.value * math.sin(sensor.angle)
			}}, { .x = 0.0, .y = 0.0 })
      if(neighbors.count() > 0) {
        obst.x = obst.x / neighbors.count()
        obst.y = obst.y / neighbors.count()
      }

  # Draw the vector
	# See: https://the.swarming.buzz/wiki/doku.php?id=buzz_argos
	debug.rays.add(
		255, 0, 0,
		0.0, 0.0, 0.1,
		obst.x, obst.y, 0.1)

  length = math.sqrt(obst.x*obst.x + obst.y*obst.y)

	threshold = 0.005
	
	if (length > threshold){
		gotoc(-obst.x*100.0, -obst.y*100.0)
	} else {
		gotoc(10.0, 0.0)
	}

  debug_output()
}

#
# Executed once upon resetting
#
function reset() {
  # Pick a default task
	math.rng.setseed(id)

	# Draw the trajectory of the robot in green
	# See: https://the.swarming.buzz/wiki/doku.php?id=buzz_argos
  # debug.trajectory.enable(100, 0, 255, 0)

  # Debug output
  debug_output()
}

#
# Executed once upon closing ARGoS
#
function destroy() {
  # Nothing to do
}

#
# Helper function
#
function debug_output() {
  # Examples of possible debug output
  
  # Debug message written on top of robot
  # See: https://the.swarming.buzz/wiki/doku.php?id=buzz_argos
  # Debug message written in the log

	# debug.print("t=", task, "; s0=", stimulus[0], "; s1=", stimulus[1], "; T0=", T[0], "; T1=", T[1])
  # log("R", id, ": t=", task, "; th0=", threshold[0], "; th1=", threshold[1])
}
